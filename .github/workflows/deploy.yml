name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY: onjourney-golink-shortner
  IMAGE_TAG: latest

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25'
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run tests
        run: go test -v ./...

  build-and-push:
    name: Build and Push to ECR
    needs: test
    runs-on: ubuntu-latest
    # Use environment if secrets are configured in GitHub Environment
    # If secrets are in repository-level, remove this line
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_NAME: ${{ env.ECR_REPOSITORY }}
        run: |
          # Build for ARM64 (Graviton)
          docker buildx create --use
          docker buildx build --platform linux/arm64 \
            -t $ECR_REGISTRY/$IMAGE_NAME:${{ github.sha }} \
            -t $ECR_REGISTRY/$IMAGE_NAME:${{ env.IMAGE_TAG }} \
            --push .
      
      - name: Get ASG Instances
        id: get-instances
        run: |
          if [ -n "${{ secrets.ASG_NAME }}" ]; then
            INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ secrets.ASG_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
              --output text)
            
            if [ -z "$INSTANCES" ] || [ "$INSTANCES" == "None" ]; then
              echo "No instances found in ASG: ${{ secrets.ASG_NAME }}"
              echo "use_asg=false" >> $GITHUB_OUTPUT
            else
              echo "Found instances in ASG: $INSTANCES"
              echo "use_asg=true" >> $GITHUB_OUTPUT
              # Save instances to file for later use (handle both space and tab separators)
              echo "$INSTANCES" | tr ' \t' '\n' | grep -v '^$' > instances.txt
              echo "Instance IDs saved to instances.txt:"
              cat instances.txt
            fi
          else
            echo "ASG_NAME not set, using single EC2"
            echo "use_asg=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy to ASG Instances via SSM
        if: steps.get-instances.outputs.use_asg == 'true'
        run: |
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          IMAGE_NAME="${{ env.ECR_REPOSITORY }}"
          IMAGE_TAG="${{ env.IMAGE_TAG }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          
          while IFS= read -r INSTANCE_ID; do
            # Skip empty lines
            if [ -z "$INSTANCE_ID" ]; then
              continue
            fi
            
            echo "=========================================="
            echo "Deploying to instance: $INSTANCE_ID"
            echo "=========================================="
            
            # Check instance state and wait for it to be ready
            echo "Checking instance state..."
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --region "$AWS_REGION" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "unknown")
            
            echo "Instance state: $INSTANCE_STATE"
            
            # Wait for instance to be running (max 5 minutes)
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "⚠️  Instance is not running (state: $INSTANCE_STATE), waiting..."
              for i in {1..30}; do
                sleep 10
                INSTANCE_STATE=$(aws ec2 describe-instances \
                  --instance-ids "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'Reservations[0].Instances[0].State.Name' \
                  --output text 2>/dev/null || echo "unknown")
                echo "  Attempt $i/30: Instance state is $INSTANCE_STATE"
                if [ "$INSTANCE_STATE" == "running" ]; then
                  echo "✅ Instance is now running"
                  break
                fi
              done
              
              if [ "$INSTANCE_STATE" != "running" ]; then
                echo "❌ Instance $INSTANCE_ID is not in running state (current: $INSTANCE_STATE)"
                echo "   Skipping deployment for this instance"
                continue
              fi
            fi
            
            # Wait for SSM agent to be ready (max 3 minutes)
            echo "Waiting for SSM agent to be ready..."
            SSM_READY=false
            for i in {1..18}; do
              sleep 10
              # Check if instance is registered with SSM
              if aws ssm describe-instance-information \
                --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query 'InstanceInformationList[0].PingStatus' \
                --output text 2>/dev/null | grep -q "Online"; then
                echo "✅ SSM agent is ready (Online)"
                SSM_READY=true
                break
              fi
              echo "  Attempt $i/18: SSM agent not ready yet, waiting..."
            done
            
            if [ "$SSM_READY" != "true" ]; then
              echo "⚠️  SSM agent not ready for instance $INSTANCE_ID"
              echo "   This might be a new instance. SSM agent typically takes 1-2 minutes to register."
              echo "   Attempting to send command anyway (might fail if agent is not ready)..."
            fi
            
            # Prepare deployment commands
            # Try to download deploy.sh from S3 if not exists, then use it or fallback
            DEPLOY_COMMANDS="export ECR_REGISTRY='$ECR_REGISTRY' && export IMAGE_NAME='$IMAGE_NAME' && export IMAGE_TAG='$IMAGE_TAG' && export AWS_REGION='$AWS_REGION' && mkdir -p /home/ec2-user/scripts && if [ ! -f /home/ec2-user/scripts/deploy.sh ]; then echo 'Downloading deploy.sh from S3...' && aws s3 cp s3://onjourney-asset-bucket/scripts/deploy.sh /home/ec2-user/scripts/deploy.sh 2>/dev/null && chmod +x /home/ec2-user/scripts/deploy.sh || echo 'Failed to download deploy.sh from S3'; fi && if [ -f /home/ec2-user/scripts/deploy.sh ]; then echo 'Using deploy.sh script...' && /home/ec2-user/scripts/deploy.sh; else echo 'Deploy script not found, deploying directly...' && mkdir -p /home/ec2-user && echo 'Always retrieving credentials from Parameter Store and replacing .env file...' && DB_HOST=\$(aws ssm get-parameter --name /golink-shorner/db/host --region \$AWS_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo '') && DB_PORT=\$(aws ssm get-parameter --name /golink-shorner/db/port --region \$AWS_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo '5432') && DB_USER=\$(aws ssm get-parameter --name /golink-shorner/db/user --region \$AWS_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo 'onjourney') && DB_PASSWORD=\$(aws ssm get-parameter --name /golink-shorner/db/password --with-decryption --region \$AWS_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo '') && DB_NAME=\$(aws ssm get-parameter --name /golink-shorner/db/name --region \$AWS_REGION --query 'Parameter.Value' --output text 2>/dev/null || echo 'onjourney_link') && if [ -z \"\$DB_HOST\" ] || [ -z \"\$DB_PASSWORD\" ]; then echo 'ERROR: Failed to retrieve credentials from Parameter Store' && exit 1; fi && echo \"DB_HOST=\$DB_HOST\" > /home/ec2-user/.env && echo \"DB_PORT=\$DB_PORT\" >> /home/ec2-user/.env && echo \"DB_USER=\$DB_USER\" >> /home/ec2-user/.env && echo \"DB_PASSWORD=\$DB_PASSWORD\" >> /home/ec2-user/.env && echo \"DB_NAME=\$DB_NAME\" >> /home/ec2-user/.env && echo \"DB_SSLMODE=require\" >> /home/ec2-user/.env && chmod 600 /home/ec2-user/.env && echo '✅ Replaced .env file with credentials from Parameter Store' && aws ecr get-login-password --region \$AWS_REGION | docker login --username AWS --password-stdin \$ECR_REGISTRY && echo 'Pulling image...' && docker pull \$ECR_REGISTRY/\$IMAGE_NAME:\$IMAGE_TAG && echo 'Stopping old container...' && docker stop golink-shorner 2>/dev/null || true && docker rm golink-shorner 2>/dev/null || true && echo 'Starting new container...' && docker run -d --name golink-shorner --restart unless-stopped -p 3000:3000 --env-file /home/ec2-user/.env \$ECR_REGISTRY/\$IMAGE_NAME:\$IMAGE_TAG && echo 'Waiting for container to start...' && sleep 10 && echo 'Checking container status...' && docker ps | grep golink-shorner &&  && echo "Ensuring nginx is running..." && if ! sudo systemctl is-active --quiet nginx; then echo "Starting nginx..." && sudo systemctl start nginx && sudo systemctl enable nginx; else echo "Reloading nginx..." && sudo systemctl reload nginx || sudo systemctl restart nginx; fi && if ! sudo systemctl is-active --quiet nginx; then echo "WARNING: nginx failed to start"; else echo "Nginx is running"; fi &&  && echo "Ensuring nginx is running..." && if ! sudo systemctl is-active --quiet nginx; then echo "Starting nginx..." && sudo systemctl start nginx && sudo systemctl enable nginx; else echo "Reloading nginx..." && sudo systemctl reload nginx || sudo systemctl restart nginx; fi && if ! sudo systemctl is-active --quiet nginx; then echo "WARNING: nginx failed to start"; else echo "Nginx is running"; fi && echo 'Performing health check...' && for i in {1..10}; do if curl -f http://localhost:3000/health 2>/dev/null; then echo 'Health check passed!' && exit 0; fi; echo \"Health check attempt \$i/10 failed, retrying...\"; sleep 3; done && echo 'Health check failed after 10 attempts' && echo 'Container logs:' && docker logs golink-shorner --tail 50 && exit 1; fi"
            
            # Create JSON parameters file for SSM (properly escaped)
            # Use jq if available, otherwise use Python for JSON escaping
            PARAMS_FILE=$(mktemp)
            if command -v jq &> /dev/null; then
              jq -n --arg cmd "$DEPLOY_COMMANDS" '{commands: [$cmd]}' > "$PARAMS_FILE"
            else
              # Fallback: use Python for JSON escaping
              python3 -c "import json, sys; json.dump({'commands': [sys.argv[1]]}, sys.stdout)" "$DEPLOY_COMMANDS" > "$PARAMS_FILE"
            fi
            
            # Send command via SSM (with retry logic for InvalidInstanceId errors)
            COMMAND_ID=""
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "Sending SSM command (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
              
              SSM_OUTPUT=$(aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters file://"$PARAMS_FILE" \
                --region "$AWS_REGION" \
                --output-s3-bucket-name "onjourney-asset-bucket" \
                --output-s3-key-prefix "ssm-commands" \
                --query 'Command.CommandId' \
                --output text 2>&1)
              
              # Check if output is a valid command ID (UUID format)
              if [[ "$SSM_OUTPUT" =~ ^[a-f0-9-]{36}$ ]]; then
                COMMAND_ID="$SSM_OUTPUT"
                echo "✅ SSM command sent successfully: $COMMAND_ID"
                break
              elif [[ "$SSM_OUTPUT" == *"InvalidInstanceId"* ]] || [[ "$SSM_OUTPUT" == *"not in a valid state"* ]]; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "⚠️  Instance not ready for SSM (InvalidInstanceId), waiting 30 seconds before retry..."
                  sleep 30
                  
                  # Re-check SSM agent status
                  SSM_STATUS=$(aws ssm describe-instance-information \
                    --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                    --region "$AWS_REGION" \
                    --query 'InstanceInformationList[0].PingStatus' \
                    --output text 2>/dev/null || echo "Unknown")
                  
                  if [ "$SSM_STATUS" == "Online" ]; then
                    echo "✅ SSM agent is now Online, retrying..."
                  else
                    echo "⚠️  SSM agent status: $SSM_STATUS (still not ready, but retrying anyway...)"
                  fi
                else
                  echo "❌ Failed to send SSM command after $MAX_RETRIES attempts"
                  echo "   Error: $SSM_OUTPUT"
                  echo "   Instance might be too new. SSM agent typically takes 1-2 minutes to register."
                  echo "   Please wait a few minutes and try deployment again, or deploy manually."
                  rm -f "$PARAMS_FILE"
                  continue 2  # Continue to next instance
                fi
              else
                # Other error
                echo "❌ Failed to send SSM command: $SSM_OUTPUT"
                rm -f "$PARAMS_FILE"
                continue 2  # Continue to next instance
              fi
            done
            
            # Cleanup temp file
            rm -f "$PARAMS_FILE"
            
            if [ -z "$COMMAND_ID" ] || [[ ! "$COMMAND_ID" =~ ^[a-f0-9-]{36}$ ]]; then
              echo "❌ Failed to send SSM command to instance $INSTANCE_ID after retries"
              continue
            fi
            
            echo "Command ID: $COMMAND_ID"
            echo "Waiting for command to complete..."
            
            # Wait for command to complete (max 5 minutes)
            STATUS="InProgress"
            for i in {1..30}; do
              sleep 10
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query 'Status' \
                --output text 2>/dev/null || echo "InProgress")
              
              if [ "$STATUS" == "Success" ]; then
                echo "✅ Deployment successful for $INSTANCE_ID"
                # Get command output
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'StandardOutputContent' \
                  --output text
                break
              elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
                echo "❌ Deployment failed for $INSTANCE_ID (Status: $STATUS)"
                # Get error output
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'StandardErrorContent' \
                  --output text
                exit 1
              fi
            done
            
            if [ "$STATUS" != "Success" ]; then
              echo "❌ Deployment timeout for $INSTANCE_ID (Status: $STATUS)"
              exit 1
            fi
          done < instances.txt
      
      - name: Verify ALB Health
        if: steps.get-instances.outputs.use_asg == 'true'
        run: |
          if [ -n "${{ secrets.ALB_DNS }}" ]; then
            echo "Checking ALB health..."
            for i in {1..10}; do
              if curl -f http://${{ secrets.ALB_DNS }}/health; then
                echo "✅ ALB health check passed"
                exit 0
              fi
              echo "Waiting for ALB... ($i/10)"
              sleep 10
            done
            echo "⚠️  ALB health check timeout (instances may still be starting)"
          else
            echo "ALB_DNS not set, skipping ALB health check"
          fi
