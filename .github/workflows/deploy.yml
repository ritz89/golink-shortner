name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY: onjourney-golink-shortner
  IMAGE_TAG: latest

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.25'
      
      - name: Download dependencies
        run: go mod download
      
      - name: Run tests
        run: go test -v ./...

  build-and-push:
    name: Build and Push to ECR
    needs: test
    runs-on: ubuntu-latest
    # Use environment if secrets are configured in GitHub Environment
    # If secrets are in repository-level, remove this line
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_NAME: ${{ env.ECR_REPOSITORY }}
        run: |
          # Build for ARM64 (Graviton)
          docker buildx create --use
          docker buildx build --platform linux/arm64 \
            -t $ECR_REGISTRY/$IMAGE_NAME:${{ github.sha }} \
            -t $ECR_REGISTRY/$IMAGE_NAME:${{ env.IMAGE_TAG }} \
            --push .
      
      - name: Get ASG Instances
        id: get-instances
        run: |
          if [ -n "${{ secrets.ASG_NAME }}" ]; then
            INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ secrets.ASG_NAME }} \
              --region ${{ env.AWS_REGION }} \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
              --output text)
            
            if [ -z "$INSTANCES" ] || [ "$INSTANCES" == "None" ]; then
              echo "No instances found in ASG: ${{ secrets.ASG_NAME }}"
              echo "use_asg=false" >> $GITHUB_OUTPUT
            else
              echo "Found instances in ASG: $INSTANCES"
              echo "use_asg=true" >> $GITHUB_OUTPUT
              # Save instances to file for later use (handle both space and tab separators)
              echo "$INSTANCES" | tr ' \t' '\n' | grep -v '^$' > instances.txt
              echo "Instance IDs saved to instances.txt:"
              cat instances.txt
            fi
          else
            echo "ASG_NAME not set, using single EC2"
            echo "use_asg=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy to ASG Instances via SSM
        if: steps.get-instances.outputs.use_asg == 'true'
        run: |
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          IMAGE_NAME="${{ env.ECR_REPOSITORY }}"
          IMAGE_TAG="${{ env.IMAGE_TAG }}"
          AWS_REGION="${{ env.AWS_REGION }}"
          
          while IFS= read -r INSTANCE_ID; do
            # Skip empty lines
            if [ -z "$INSTANCE_ID" ]; then
              continue
            fi
            
            echo "=========================================="
            echo "Deploying to instance: $INSTANCE_ID"
            echo "=========================================="
            
            # Check instance state and wait for it to be ready
            echo "Checking instance state..."
            INSTANCE_STATE=$(aws ec2 describe-instances \
              --instance-ids "$INSTANCE_ID" \
              --region "$AWS_REGION" \
              --query 'Reservations[0].Instances[0].State.Name' \
              --output text 2>/dev/null || echo "unknown")
            
            echo "Instance state: $INSTANCE_STATE"
            
            # Wait for instance to be running (max 5 minutes)
            if [ "$INSTANCE_STATE" != "running" ]; then
              echo "⚠️  Instance is not running (state: $INSTANCE_STATE), waiting..."
              for i in {1..30}; do
                sleep 10
                INSTANCE_STATE=$(aws ec2 describe-instances \
                  --instance-ids "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'Reservations[0].Instances[0].State.Name' \
                  --output text 2>/dev/null || echo "unknown")
                echo "  Attempt $i/30: Instance state is $INSTANCE_STATE"
                if [ "$INSTANCE_STATE" == "running" ]; then
                  echo "✅ Instance is now running"
                  break
                fi
              done
              
              if [ "$INSTANCE_STATE" != "running" ]; then
                echo "❌ Instance $INSTANCE_ID is not in running state (current: $INSTANCE_STATE)"
                echo "   Skipping deployment for this instance"
                continue
              fi
            fi
            
            # Wait for SSM agent to be ready (max 3 minutes)
            echo "Waiting for SSM agent to be ready...."
            SSM_READY=false
            for i in {1..18}; do
              sleep 10
              # Check if instance is registered with SSM
              if aws ssm describe-instance-information \
                --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query 'InstanceInformationList[0].PingStatus' \
                --output text 2>/dev/null | grep -q "Online"; then
                echo "✅ SSM agent is ready (Online)"
                SSM_READY=true
                break
              fi
              echo "  Attempt $i/18: SSM agent not ready yet, waiting..."
            done
            
            if [ "$SSM_READY" != "true" ]; then
              echo "⚠️  SSM agent not ready for instance $INSTANCE_ID"
              echo "   This might be a new instance. SSM agent typically takes 1-2 minutes to register."
              echo "   Attempting to send command anyway (might fail if agent is not ready)..."
            fi
            
            # Prepare deployment commands
            # Use deploy.sh script from S3 as the primary deployment method
            # This approach is cleaner, more maintainable, and easier to debug
            DEPLOY_COMMANDS="mkdir -p /home/ec2-user/scripts && echo 'Downloading deploy.sh from S3...' && if aws s3 cp s3://onjourney-asset-bucket/scripts/deploy.sh /home/ec2-user/scripts/deploy.sh; then chmod +x /home/ec2-user/scripts/deploy.sh && echo 'Setting environment variables...' && export ECR_REGISTRY='$ECR_REGISTRY' && export IMAGE_NAME='$IMAGE_NAME' && export IMAGE_TAG='$IMAGE_TAG' && export AWS_REGION='$AWS_REGION' && echo 'Running deploy.sh script...' && /home/ec2-user/scripts/deploy.sh; else echo 'ERROR: Failed to download deploy.sh from S3. Please ensure:' && echo '  1. Script is uploaded to S3: ./scripts/upload-to-s3.sh' && echo '  2. IAM role has S3 read permissions' && echo '  3. S3 bucket exists: onjourney-asset-bucket' && exit 1; fi"
            
            # Create JSON parameters file for SSM (properly escaped)
            # Use jq if available, otherwise use Python for JSON escaping
            PARAMS_FILE=$(mktemp)
            if command -v jq &> /dev/null; then
              jq -n --arg cmd "$DEPLOY_COMMANDS" '{commands: [$cmd]}' > "$PARAMS_FILE"
            else
              # Fallback: use Python for JSON escaping
              python3 -c "import json, sys; json.dump({'commands': [sys.argv[1]]}, sys.stdout)" "$DEPLOY_COMMANDS" > "$PARAMS_FILE"
            fi
            
            # Debug: Show the deployment command
            echo "=========================================="
            echo "Deployment Command:"
            echo "=========================================="
            echo "$DEPLOY_COMMANDS"
            echo "=========================================="
            echo "This command will:"
            echo "  1. Download deploy.sh from S3"
            echo "  2. Set required environment variables"
            echo "  3. Execute deploy.sh script"
            echo "=========================================="
            
            # Send command via SSM (with retry logic for InvalidInstanceId errors)
            COMMAND_ID=""
            MAX_RETRIES=3
            RETRY_COUNT=0
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "Sending SSM command (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)..."
              
              SSM_OUTPUT=$(aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters file://"$PARAMS_FILE" \
                --region "$AWS_REGION" \
                --output-s3-bucket-name "onjourney-asset-bucket" \
                --output-s3-key-prefix "ssm-commands" \
                --query 'Command.CommandId' \
                --output text 2>&1)
              
              # Check if output is a valid command ID (UUID format)
              if [[ "$SSM_OUTPUT" =~ ^[a-f0-9-]{36}$ ]]; then
                COMMAND_ID="$SSM_OUTPUT"
                echo "✅ SSM command sent successfully: $COMMAND_ID"
                break
              elif [[ "$SSM_OUTPUT" == *"InvalidInstanceId"* ]] || [[ "$SSM_OUTPUT" == *"not in a valid state"* ]]; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "⚠️  Instance not ready for SSM (InvalidInstanceId), waiting 30 seconds before retry..."
                  sleep 30
                  
                  # Re-check SSM agent status
                  SSM_STATUS=$(aws ssm describe-instance-information \
                    --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                    --region "$AWS_REGION" \
                    --query 'InstanceInformationList[0].PingStatus' \
                    --output text 2>/dev/null || echo "Unknown")
                  
                  if [ "$SSM_STATUS" == "Online" ]; then
                    echo "✅ SSM agent is now Online, retrying..."
                  else
                    echo "⚠️  SSM agent status: $SSM_STATUS (still not ready, but retrying anyway...)"
                  fi
                else
                  echo "❌ Failed to send SSM command after $MAX_RETRIES attempts"
                  echo "   Error: $SSM_OUTPUT"
                  echo "   Instance might be too new. SSM agent typically takes 1-2 minutes to register."
                  echo "   Please wait a few minutes and try deployment again, or deploy manually."
                  rm -f "$PARAMS_FILE"
                  continue 2  # Continue to next instance
                fi
              else
                # Other error
                echo "❌ Failed to send SSM command: $SSM_OUTPUT"
                rm -f "$PARAMS_FILE"
                continue 2  # Continue to next instance
              fi
            done
            
            # Cleanup temp file
            rm -f "$PARAMS_FILE"
            
            if [ -z "$COMMAND_ID" ] || [[ ! "$COMMAND_ID" =~ ^[a-f0-9-]{36}$ ]]; then
              echo "❌ Failed to send SSM command to instance $INSTANCE_ID after retries"
              continue
            fi
            
            echo "Command ID: $COMMAND_ID"
            
            # Debug: Show command structure before execution
            echo "=========================================="
            echo "DEBUG: Command structure (first 500 chars):"
            echo "=========================================="
            echo "$DEPLOY_COMMANDS" | head -c 500
            echo ""
            echo "=========================================="
            echo "DEBUG: Syntax check..."
            echo "=========================================="
            if echo "$DEPLOY_COMMANDS" | grep -q '&& ;'; then
              echo "❌ WARNING: Found '&& ;' pattern in command!"
            else
              echo "✅ No '&& ;' pattern found"
            fi
            if echo "$DEPLOY_COMMANDS" | grep -q 'fi && ; fi'; then
              echo "❌ WARNING: Found 'fi && ; fi' pattern in command!"
            else
              echo "✅ No 'fi && ; fi' pattern found"
            fi
            echo "DEBUG: Nginx command area:"
            echo "$DEPLOY_COMMANDS" | grep -o 'Ensuring nginx.*Performing health check' | head -c 300 || echo "Could not extract nginx area"
            echo ""
            echo "=========================================="
            echo "Waiting for command to complete..."
            
            # Wait for command to complete (max 5 minutes)
            STATUS="InProgress"
            for i in {1..30}; do
              sleep 10
              STATUS=$(aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --region "$AWS_REGION" \
                --query 'Status' \
                --output text 2>/dev/null || echo "InProgress")
              
              if [ "$STATUS" == "Success" ]; then
                echo "✅ Deployment successful for $INSTANCE_ID"
                # Get command output
                echo "=========================================="
                echo "Command Output:"
                echo "=========================================="
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'StandardOutputContent' \
                  --output text
                echo "=========================================="
                break
              elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ] || [ "$STATUS" == "TimedOut" ]; then
                echo "❌ Deployment failed for $INSTANCE_ID (Status: $STATUS)"
                
                # Get full command details for debugging
                echo "=========================================="
                echo "DEBUG: Full Command Details:"
                echo "=========================================="
                aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query '{Status:Status,ResponseCode:ResponseCode,ExecutionStartDateTime:ExecutionStartDateTime,ExecutionEndDateTime:ExecutionEndDateTime}' \
                  --output json 2>/dev/null || echo "Could not get command details"
                
                echo "=========================================="
                echo "Command Output (Full):"
                echo "=========================================="
                OUTPUT=$(aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'StandardOutputContent' \
                  --output text 2>/dev/null || echo "No output available")
                echo "$OUTPUT"
                
                echo "=========================================="
                echo "Command Error Output (Full):"
                echo "=========================================="
                ERROR_OUTPUT=$(aws ssm get-command-invocation \
                  --command-id "$COMMAND_ID" \
                  --instance-id "$INSTANCE_ID" \
                  --region "$AWS_REGION" \
                  --query 'StandardErrorContent' \
                  --output text 2>/dev/null || echo "No error output available")
                echo "$ERROR_OUTPUT"
                
                # Check for the specific error
                if echo "$ERROR_OUTPUT" | grep -q "nginx: invalid option"; then
                  echo "=========================================="
                  echo "❌ DETECTED: 'nginx: invalid option' error"
                  echo "=========================================="
                  echo "This suggests a command parsing issue."
                  echo "Checking command structure around nginx..."
                  echo "$DEPLOY_COMMANDS" | grep -o 'systemctl.*nginx.*Performing' | head -c 300 || echo "Could not extract nginx command area"
                  echo ""
                fi
                
                echo "=========================================="
                exit 1
              fi
            done
            
            if [ "$STATUS" != "Success" ]; then
              echo "❌ Deployment timeout for $INSTANCE_ID (Status: $STATUS)"
              exit 1
            fi
          done < instances.txt
      
      - name: Verify ALB Health
        if: steps.get-instances.outputs.use_asg == 'true'
        run: |
          if [ -n "${{ secrets.ALB_DNS }}" ]; then
            echo "Checking ALB health..."
            for i in {1..10}; do
              if curl -f http://${{ secrets.ALB_DNS }}/health; then
                echo "✅ ALB health check passed"
                exit 0
              fi
              echo "Waiting for ALB... ($i/10)"
              sleep 10
            done
            echo "⚠️  ALB health check timeout (instances may still be starting)"
          else
            echo "ALB_DNS not set, skipping ALB health check"
          fi
